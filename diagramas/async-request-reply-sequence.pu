@startuml async-request-reply-sequence
!theme plain
title Asynchronous Request-Reply - Diagrama de Secuencia

actor Usuario
participant "Tomcat\nThread Pool\n(HTTP)" as Tomcat
participant "PlaybackController" as Controller
participant "CompletableFuture" as CF
participant "Async\nThread Pool\n(5-10 threads)" as AsyncPool
participant "PlaybackService" as Service
participant "Flaky Service" as Flaky

' Lifelines
activate Usuario
activate Tomcat
activate Controller
activate CF
activate AsyncPool
activate Service
activate Flaky

Usuario -> Tomcat: POST /playback/start?trackId=T1
activate Tomcat

Tomcat -> Controller: start(trackId, auth)
activate Controller

note right of Controller
  Método retorna
  CompletableFuture<ResponseEntity>
  No bloquea thread del Tomcat
end note

Controller -> CF: CompletableFuture.supplyAsync(...)
activate CF

CF -> AsyncPool: Submit task
activate AsyncPool

note right of AsyncPool
  Thread pool dedicado
  para operaciones async
  
  Core: 5 threads
  Max: 10 threads
  Queue: 100 tasks
end note

Controller --> Tomcat: CompletableFuture (inmediato)
deactivate Controller

note right of Tomcat
  Thread del Tomcat liberado
  Puede atender otras requests
  
  Tiempo: ~5ms
end note

Tomcat --> Usuario: Response (async, no bloqueante)
deactivate Tomcat

note right of Usuario
  Usuario recibe respuesta
  cuando operación completa
  
  Connection keep-alive
end note

== Procesamiento Asíncrono (en paralelo) ==

AsyncPool -> Service: startPlayback(userId, trackId)
activate Service

Service -> Flaky: getStreamUrl(trackId)
activate Flaky

note right of Service
  Operación puede tardar:
  - Retries
  - Circuit breaker
  - Timeouts
  
  No bloquea threads del Tomcat
end note

Flaky --> Service: streamUrl (después de retries)
deactivate Flaky

Service --> AsyncPool: PlaybackDTO
deactivate Service

AsyncPool --> CF: Result
deactivate AsyncPool

CF --> Usuario: 200 OK ResponseEntity<PlaybackDTO>

note right of Usuario
  Respuesta asíncrona
  Tiempo total: variable
  (depende de retries)
end note

' End lifelines
deactivate Usuario
deactivate Tomcat
deactivate Controller
deactivate CF
deactivate AsyncPool
deactivate Service
deactivate Flaky

== Múltiples Requests Concurrentes ==

participant "Usuario 2" as U2
participant "Usuario 3" as U3

U2 -> Tomcat: POST /playback/start?trackId=T2
activate Tomcat
Tomcat -> Controller: start("T2", auth)
activate Controller
Controller -> CF: CompletableFuture.supplyAsync(...)
activate CF
CF -> AsyncPool: Submit task 2
Controller --> Tomcat: CompletableFuture
deactivate Controller
Tomcat --> U2: Response
deactivate Tomcat

U3 -> Tomcat: POST /playback/start?trackId=T3
activate Tomcat
Tomcat -> Controller: start("T3", auth)
activate Controller
Controller -> CF: CompletableFuture.supplyAsync(...)
CF -> AsyncPool: Submit task 3
Controller --> Tomcat: CompletableFuture
deactivate Controller
Tomcat --> U3: Response
deactivate Tomcat

note over AsyncPool
  3 tasks procesándose
  concurrentemente en
  thread pool async
  
  Threads Tomcat libres
  para más requests HTTP
end note

AsyncPool --> U2: Result task 2
AsyncPool --> U3: Result task 3
deactivate CF

@enduml
